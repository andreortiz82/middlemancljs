{
"version":3,
"file":"module$node_modules$schedule$cjs$schedule_development.js",
"lineCount":12,
"mappings":"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",
"sources":["node_modules/schedule/cjs/schedule.development.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$schedule$cjs$schedule_development\"] = function(global,process,require,module,exports,shadow$shims) {\n/** @license React v16.5.1\n * schedule.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n'use strict';\n\n\n\nif (process.env.NODE_ENV !== \"production\") {\n  (function() {\n'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);\n\n/**\n * A scheduling library to allow scheduling work with more granular priority and\n * control than requestAnimationFrame and requestIdleCallback.\n * Current TODO items:\n * X- Pull out the scheduleWork polyfill built into React\n * X- Initial test coverage\n * X- Support for multiple callbacks\n * - Support for two priorities; serial and deferred\n * - Better test coverage\n * - Better docblock\n * - Polish documentation, API\n */\n\n// This is a built-in polyfill for requestIdleCallback. It works by scheduling\n// a requestAnimationFrame, storing the time for the start of the frame, then\n// scheduling a postMessage which gets scheduled after paint. Within the\n// postMessage handler do as much work as possible until time + frame rate.\n// By separating the idle call into a separate event tick we ensure that\n// layout, paint and other browser work is counted against the available time.\n// The frame rate is dynamically adjusted.\n\n// We capture a local reference to any global, in case it gets polyfilled after\n// this module is initially evaluated.\n// We want to be using a consistent implementation.\nvar localDate = Date;\n\n// This initialization code may run even on server environments\n// if a component just imports ReactDOM (e.g. for findDOMNode).\n// Some environments might not have setTimeout or clearTimeout.\n// However, we always expect them to be defined on the client.\n// https://github.com/facebook/react/pull/13088\nvar localSetTimeout = typeof setTimeout === 'function' ? setTimeout : undefined;\nvar localClearTimeout = typeof clearTimeout === 'function' ? clearTimeout : undefined;\n\n// We don't expect either of these to necessarily be defined,\n// but we will error later if they are missing on the client.\nvar localRequestAnimationFrame = typeof requestAnimationFrame === 'function' ? requestAnimationFrame : undefined;\nvar localCancelAnimationFrame = typeof cancelAnimationFrame === 'function' ? cancelAnimationFrame : undefined;\n\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\n\nexports.unstable_now = void 0;\nif (hasNativePerformanceNow) {\n  var Performance = performance;\n  exports.unstable_now = function () {\n    return Performance.now();\n  };\n} else {\n  exports.unstable_now = function () {\n    return localDate.now();\n  };\n}\n\nexports.unstable_scheduleWork = void 0;\nexports.unstable_cancelScheduledWork = void 0;\n\nif (!canUseDOM) {\n  var timeoutIds = new Map();\n\n  exports.unstable_scheduleWork = function (callback, options) {\n    // keeping return type consistent\n    var callbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: 0,\n      next: null,\n      prev: null\n    };\n    var timeoutId = localSetTimeout(function () {\n      callback({\n        timeRemaining: function () {\n          return Infinity;\n        },\n\n        didTimeout: false\n      });\n    });\n    timeoutIds.set(callback, timeoutId);\n    return callbackConfig;\n  };\n  exports.unstable_cancelScheduledWork = function (callbackId) {\n    var callback = callbackId.scheduledCallback;\n    var timeoutId = timeoutIds.get(callback);\n    timeoutIds.delete(callbackId);\n    localClearTimeout(timeoutId);\n  };\n} else {\n  {\n    if (typeof console !== 'undefined') {\n      if (typeof localRequestAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support requestAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n      if (typeof localCancelAnimationFrame !== 'function') {\n        console.error(\"This browser doesn't support cancelAnimationFrame. \" + 'Make sure that you load a ' + 'polyfill in older browsers. https://fb.me/react-polyfills');\n      }\n    }\n  }\n\n  var headOfPendingCallbacksLinkedList = null;\n  var tailOfPendingCallbacksLinkedList = null;\n\n  // We track what the next soonest timeoutTime is, to be able to quickly tell\n  // if none of the scheduled callbacks have timed out.\n  var nextSoonestTimeoutTime = -1;\n\n  var isIdleScheduled = false;\n  var isAnimationFrameScheduled = false;\n\n  // requestAnimationFrame does not run when the tab is in the background.\n  // if we're backgrounded we prefer for that work to happen so that the page\n  // continues\tto load in the background.\n  // so we also schedule a 'setTimeout' as a fallback.\n  var animationFrameTimeout = 100;\n  var rafID = void 0;\n  var timeoutID = void 0;\n  var scheduleAnimationFrameWithFallbackSupport = function (callback) {\n    // schedule rAF and also a setTimeout\n    rafID = localRequestAnimationFrame(function (timestamp) {\n      // cancel the setTimeout\n      localClearTimeout(timeoutID);\n      callback(timestamp);\n    });\n    timeoutID = localSetTimeout(function () {\n      // cancel the requestAnimationFrame\n      localCancelAnimationFrame(rafID);\n      callback(exports.unstable_now());\n    }, animationFrameTimeout);\n  };\n\n  var frameDeadline = 0;\n  // We start out assuming that we run at 30fps but then the heuristic tracking\n  // will adjust this value to a faster fps if we get more frequent animation\n  // frames.\n  var previousFrameTime = 33;\n  var activeFrameTime = 33;\n\n  var frameDeadlineObject = {\n    didTimeout: false,\n    timeRemaining: function () {\n      var remaining = frameDeadline - exports.unstable_now();\n      return remaining > 0 ? remaining : 0;\n    }\n  };\n\n  /**\n   * Handles the case where a callback errors:\n   * - don't catch the error, because this changes debugging behavior\n   * - do start a new postMessage callback, to call any remaining callbacks,\n   * - but only if there is an error, so there is not extra overhead.\n   */\n  var callUnsafely = function (callbackConfig, arg) {\n    var callback = callbackConfig.scheduledCallback;\n    var finishedCalling = false;\n    try {\n      callback(arg);\n      finishedCalling = true;\n    } finally {\n      // always remove it from linked list\n      exports.unstable_cancelScheduledWork(callbackConfig);\n\n      if (!finishedCalling) {\n        // an error must have been thrown\n        isIdleScheduled = true;\n        window.postMessage(messageKey, '*');\n      }\n    }\n  };\n\n  /**\n   * Checks for timed out callbacks, runs them, and then checks again to see if\n   * any more have timed out.\n   * Keeps doing this until there are none which have currently timed out.\n   */\n  var callTimedOutCallbacks = function () {\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    var currentTime = exports.unstable_now();\n    // TODO: this would be more efficient if deferred callbacks are stored in\n    // min heap.\n    // Or in a linked list with links for both timeoutTime order and insertion\n    // order.\n    // For now an easy compromise is the current approach:\n    // Keep a pointer to the soonest timeoutTime, and check that first.\n    // If it has not expired, we can skip traversing the whole list.\n    // If it has expired, then we step through all the callbacks.\n    if (nextSoonestTimeoutTime === -1 || nextSoonestTimeoutTime > currentTime) {\n      // We know that none of them have timed out yet.\n      return;\n    }\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    // If a timed out callback throws an error, we could get stuck in a state\n    // where the nextSoonestTimeoutTime was set wrong.\n    var updatedNextSoonestTimeoutTime = -1; // we will update nextSoonestTimeoutTime below\n    var timedOutCallbacks = [];\n\n    // iterate once to find timed out callbacks and find nextSoonestTimeoutTime\n    var currentCallbackConfig = headOfPendingCallbacksLinkedList;\n    while (currentCallbackConfig !== null) {\n      var _timeoutTime = currentCallbackConfig.timeoutTime;\n      if (_timeoutTime !== -1 && _timeoutTime <= currentTime) {\n        // it has timed out!\n        timedOutCallbacks.push(currentCallbackConfig);\n      } else {\n        if (_timeoutTime !== -1 && (updatedNextSoonestTimeoutTime === -1 || _timeoutTime < updatedNextSoonestTimeoutTime)) {\n          updatedNextSoonestTimeoutTime = _timeoutTime;\n        }\n      }\n      currentCallbackConfig = currentCallbackConfig.next;\n    }\n\n    if (timedOutCallbacks.length > 0) {\n      frameDeadlineObject.didTimeout = true;\n      for (var i = 0, len = timedOutCallbacks.length; i < len; i++) {\n        callUnsafely(timedOutCallbacks[i], frameDeadlineObject);\n      }\n    }\n\n    // NOTE: we intentionally wait to update the nextSoonestTimeoutTime until\n    // after successfully calling any timed out callbacks.\n    nextSoonestTimeoutTime = updatedNextSoonestTimeoutTime;\n  };\n\n  // We use the postMessage trick to defer idle work until after the repaint.\n  var messageKey = '__reactIdleCallback$' + Math.random().toString(36).slice(2);\n  var idleTick = function (event) {\n    if (event.source !== window || event.data !== messageKey) {\n      return;\n    }\n    isIdleScheduled = false;\n\n    if (headOfPendingCallbacksLinkedList === null) {\n      return;\n    }\n\n    // First call anything which has timed out, until we have caught up.\n    callTimedOutCallbacks();\n\n    var currentTime = exports.unstable_now();\n    // Next, as long as we have idle time, try calling more callbacks.\n    while (frameDeadline - currentTime > 0 && headOfPendingCallbacksLinkedList !== null) {\n      var latestCallbackConfig = headOfPendingCallbacksLinkedList;\n      frameDeadlineObject.didTimeout = false;\n      // callUnsafely will remove it from the head of the linked list\n      callUnsafely(latestCallbackConfig, frameDeadlineObject);\n      currentTime = exports.unstable_now();\n    }\n    if (headOfPendingCallbacksLinkedList !== null) {\n      if (!isAnimationFrameScheduled) {\n        // Schedule another animation callback so we retry later.\n        isAnimationFrameScheduled = true;\n        scheduleAnimationFrameWithFallbackSupport(animationTick);\n      }\n    }\n  };\n  // Assumes that we have addEventListener in this environment. Might need\n  // something better for old IE.\n  window.addEventListener('message', idleTick, false);\n\n  var animationTick = function (rafTime) {\n    isAnimationFrameScheduled = false;\n    var nextFrameTime = rafTime - frameDeadline + activeFrameTime;\n    if (nextFrameTime < activeFrameTime && previousFrameTime < activeFrameTime) {\n      if (nextFrameTime < 8) {\n        // Defensive coding. We don't support higher frame rates than 120hz.\n        // If we get lower than that, it is probably a bug.\n        nextFrameTime = 8;\n      }\n      // If one frame goes long, then the next one can be short to catch up.\n      // If two frames are short in a row, then that's an indication that we\n      // actually have a higher frame rate than what we're currently optimizing.\n      // We adjust our heuristic dynamically accordingly. For example, if we're\n      // running on 120hz display or 90hz VR display.\n      // Take the max of the two in case one of them was an anomaly due to\n      // missed frame deadlines.\n      activeFrameTime = nextFrameTime < previousFrameTime ? previousFrameTime : nextFrameTime;\n    } else {\n      previousFrameTime = nextFrameTime;\n    }\n    frameDeadline = rafTime + activeFrameTime;\n    if (!isIdleScheduled) {\n      isIdleScheduled = true;\n      window.postMessage(messageKey, '*');\n    }\n  };\n\n  exports.unstable_scheduleWork = function (callback, options) /* CallbackConfigType */{\n    var timeoutTime = -1;\n    if (options != null && typeof options.timeout === 'number') {\n      timeoutTime = exports.unstable_now() + options.timeout;\n    }\n    if (nextSoonestTimeoutTime === -1 || timeoutTime !== -1 && timeoutTime < nextSoonestTimeoutTime) {\n      nextSoonestTimeoutTime = timeoutTime;\n    }\n\n    var scheduledCallbackConfig = {\n      scheduledCallback: callback,\n      timeoutTime: timeoutTime,\n      prev: null,\n      next: null\n    };\n    if (headOfPendingCallbacksLinkedList === null) {\n      // Make this callback the head and tail of our list\n      headOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    } else {\n      // Add latest callback as the new tail of the list\n      scheduledCallbackConfig.prev = tailOfPendingCallbacksLinkedList;\n      // renaming for clarity\n      var oldTailOfPendingCallbacksLinkedList = tailOfPendingCallbacksLinkedList;\n      if (oldTailOfPendingCallbacksLinkedList !== null) {\n        oldTailOfPendingCallbacksLinkedList.next = scheduledCallbackConfig;\n      }\n      tailOfPendingCallbacksLinkedList = scheduledCallbackConfig;\n    }\n\n    if (!isAnimationFrameScheduled) {\n      // If rAF didn't already schedule one, we need to schedule a frame.\n      // TODO: If this rAF doesn't materialize because the browser throttles, we\n      // might want to still have setTimeout trigger scheduleWork as a backup to ensure\n      // that we keep performing work.\n      isAnimationFrameScheduled = true;\n      scheduleAnimationFrameWithFallbackSupport(animationTick);\n    }\n    return scheduledCallbackConfig;\n  };\n\n  exports.unstable_cancelScheduledWork = function (callbackConfig /* CallbackConfigType */\n  ) {\n    if (callbackConfig.prev === null && headOfPendingCallbacksLinkedList !== callbackConfig) {\n      // this callbackConfig has already been cancelled.\n      // cancelScheduledWork should be idempotent, a no-op after first call.\n      return;\n    }\n\n    /**\n     * There are four possible cases:\n     * - Head/nodeToRemove/Tail -> null\n     *   In this case we set Head and Tail to null.\n     * - Head -> ... middle nodes... -> Tail/nodeToRemove\n     *   In this case we point the middle.next to null and put middle as the new\n     *   Tail.\n     * - Head/nodeToRemove -> ...middle nodes... -> Tail\n     *   In this case we point the middle.prev at null and move the Head to\n     *   middle.\n     * - Head -> ... ?some nodes ... -> nodeToRemove -> ... ?some nodes ... -> Tail\n     *   In this case we point the Head.next to the Tail and the Tail.prev to\n     *   the Head.\n     */\n    var next = callbackConfig.next;\n    var prev = callbackConfig.prev;\n    callbackConfig.next = null;\n    callbackConfig.prev = null;\n    if (next !== null) {\n      // we have a next\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is somewhere in the middle of a list of 3 or more nodes.\n        prev.next = next;\n        next.prev = prev;\n        return;\n      } else {\n        // there is a next but not a previous one;\n        // callbackConfig is the head of a list of 2 or more other nodes.\n        next.prev = null;\n        headOfPendingCallbacksLinkedList = next;\n        return;\n      }\n    } else {\n      // there is no next callback config; this must the tail of the list\n\n      if (prev !== null) {\n        // we have a prev\n\n        // callbackConfig is the tail of a list of 2 or more other nodes.\n        prev.next = null;\n        tailOfPendingCallbacksLinkedList = prev;\n        return;\n      } else {\n        // there is no previous callback config;\n        // callbackConfig is the only thing in the linked list,\n        // so both head and tail point to it.\n        headOfPendingCallbacksLinkedList = null;\n        tailOfPendingCallbacksLinkedList = null;\n        return;\n      }\n    }\n  };\n}\n  })();\n}\n\n};"],
"names":["shadow$provide","global","process","require","module","exports","shadow$shims","Object","defineProperty","value","canUseDOM","window","document","createElement","localDate","Date","localSetTimeout","setTimeout","undefined","localClearTimeout","clearTimeout","localRequestAnimationFrame","requestAnimationFrame","localCancelAnimationFrame","cancelAnimationFrame","hasNativePerformanceNow","performance","now","unstable_now","Performance","exports.unstable_now","unstable_scheduleWork","unstable_cancelScheduledWork","console","error","headOfPendingCallbacksLinkedList","tailOfPendingCallbacksLinkedList","nextSoonestTimeoutTime","isIdleScheduled","isAnimationFrameScheduled","rafID","timeoutID","scheduleAnimationFrameWithFallbackSupport","callback","timestamp","animationFrameTimeout","frameDeadline","previousFrameTime","activeFrameTime","frameDeadlineObject","didTimeout","timeRemaining","remaining","callUnsafely","callbackConfig","arg","scheduledCallback","finishedCalling","postMessage","messageKey","Math","random","toString","slice","addEventListener","idleTick","event","source","data","currentTime","updatedNextSoonestTimeoutTime","timedOutCallbacks","currentCallbackConfig","_timeoutTime","timeoutTime","push","next","length","len","i","latestCallbackConfig","animationTick","rafTime","nextFrameTime","exports.unstable_scheduleWork","options","timeout","scheduledCallbackConfig","prev","oldTailOfPendingCallbacksLinkedList","exports.unstable_cancelScheduledWork","timeoutIds","Map","timeoutId","Infinity","set","callbackId","get","delete"]
}
